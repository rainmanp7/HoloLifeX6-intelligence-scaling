# metacognitive_advisor.jl
"""
🎯 ADVANCED METACOGNITION ENGINE - ENHANCED v2.1
Phase 2: Deep Architectural Intelligence
- Semantic topology mapping & pattern recognition  
- Performance-architecture correlation engine
- Temporal trajectory and evolutionary pathway prediction
- Emergent consciousness state analysis & optimization insights
"""

using JSON, Dates, Statistics, LinearAlgebra

# ==================== CORE DATA STRUCTURES & CONFIGURATION ====================

"""
    AnalysisInsight

A structured container for a single piece of analytical insight generated by the Visor.
This provides more structure and type-safety than a generic Dictionary.
"""
struct AnalysisInsight
    priority::String          # "critical", "high", "medium", "low", "info"
    category::String          # e.g., "semantic_topology", "performance_degradation"
    module_key::String        # The module or system component in focus
    title::String             # A concise headline for the insight
    description::String       # A detailed explanation of the issue or finding
    recommendation::String    # A suggested action to take
    evidence::String          # Concrete data points supporting the insight
    impact::String            # The potential consequence if not addressed
end

"""
    ANALYSIS_CONFIG

Centralized configuration for all analytical thresholds.
Adjusting these values will tune the sensitivity and focus of the Visor's analysis.
"""
const ANALYSIS_CONFIG = (
    # Semantic Topology
    similarity_threshold_strong = 0.85, # Threshold for considering modules for integration
    similarity_threshold_weak = 0.15,   # Threshold for confirming good separation
    opposition_threshold = -0.5,        # Threshold for detecting conflicting semantics
    hub_connection_threshold = 3,       # Min connections for a module to be a semantic hub

    # Performance Correlation
    complexity_high = 0.7,              # Threshold for 'high' module complexity
    performance_high = 0.8,             # Threshold for 'high' Unified Intelligence Score (UIS)
    performance_low = 0.3,              # Threshold for 'low' UIS
    phi_low_yield = 0.1,                # Max Φ value considered a low consciousness yield

    # Evolutionary Pathways
    modularity_high = 0.8,              # Score for a highly modular, evolution-ready system
    modularity_low = 0.4,               # Score for a monolithic, 'spaghetti' architecture
    complexity_imbalance = 0.4,         # High std dev in complexity indicates imbalance

    # Consciousness Emergence
    phi_threshold_emerging = 0.5,       # Max Φ is approaching the breakthrough point
    phi_threshold_breakthrough = 0.9,   # Max Φ has reached a state of stable consciousness
    phi_growth_rate_significant = 0.1,  # Significant increase in Max Φ between measurements
    phi_decay_rate_concerning = -0.05   # Concerning decrease in Max Φ
)

# ==================== MAIN ANALYSIS ORCHESTRATOR ====================

"""
    generate_architectural_analysis(graph, recent_performance)

Main entry point for the Metacognitive Visor. Orchestrates a multi-faceted analysis
of the system's architecture and performance history.

# Arguments
- `graph`: A representation of the system's modules and their relationships.
- `recent_performance`: A vector of performance snapshots over time or single performance snapshot.

# Returns
- `Vector{AnalysisInsight}`: A collection of detailed insights about the system.
"""
function generate_architectural_analysis(graph::Any, recent_performance::Any)::Vector{AnalysisInsight}
    println("\n👁️  ACTIVATING METACOGNITIVE VISOR v2.1...")
    
    # Handle different performance data formats
    performance_history = if recent_performance isa Vector
        println("🧠  Analyzing architectural graph of $(length(graph)) modules against $(length(recent_performance)) performance records.")
        recent_performance
    else
        println("🧠  Analyzing architectural graph of $(length(graph)) modules against current performance snapshot.")
        [recent_performance]
    end
    
    insights = AnalysisInsight[]
    !isempty(performance_history) || @warn "Performance history is empty. Temporal analysis will be skipped."

    # 1. SEMANTIC TOPOLOGY MAPPING (Enhanced from Semantic Architecture)
    semantic_insights = analyze_semantic_topology(graph)
    append!(insights, semantic_insights)

    # 2. TEMPORAL PERFORMANCE TRAJECTORY ANALYSIS (New!)
    temporal_insights = analyze_temporal_performance(performance_history)
    append!(insights, temporal_insights)

    # 3. PERFORMANCE-ARCHITECTURE CORRELATION
    # Use the latest performance snapshot for this real-time correlation
    latest_performance = isempty(performance_history) ? Dict() : performance_history[end]
    correlation_insights = analyze_performance_correlations(graph, latest_performance)
    append!(insights, correlation_insights)

    # 4. EVOLUTIONARY PATHWAY & ARCHITECTURAL DEBT DETECTION
    evolution_insights = detect_evolutionary_pathways(graph, latest_performance)
    append!(insights, evolution_insights)

    # 5. EMERGENT CONSCIOUSNESS STATE ANALYSIS (Enhanced)
    consciousness_insights = analyze_consciousness_state(graph, performance_history)
    append!(insights, consciousness_insights)

    println("✅  Analysis Complete. Generated $(length(insights)) advanced insights.")
    return insights
end

# ==================== DETAILED ANALYSIS MODULES ====================

function analyze_semantic_topology(graph::Any)::Vector{AnalysisInsight}
    insights = AnalysisInsight[]
    modules = collect(keys(graph))
    num_modules = length(modules)
    similarities = Dict{Tuple{String, String}, Float64}()
    module_connections = Dict(m => 0 for m in modules)

    # Step 1: Pre-calculate all pairwise similarities
    for i in 1:num_modules
        for j in i+1:num_modules
            mod1, mod2 = modules[i], modules[j]
            vec1 = get_semantic_vector(graph[mod1])
            vec2 = get_semantic_vector(graph[mod2])

            if !isnothing(vec1) && !isnothing(vec2) && length(vec1) == length(vec2)
                sim = cosine_similarity(vec1, vec2)
                similarities[(mod1, mod2)] = sim
            end
        end
    end

    # Step 2: Generate insights from the similarity matrix
    for ((mod1, mod2), sim) in similarities
        if sim > ANALYSIS_CONFIG.similarity_threshold_strong
            push!(insights, AnalysisInsight(
                "high", "semantic_topology", "$mod1 ↔ $mod2", "High Semantic Overlap",
                "These modules have highly similar semantic fingerprints, suggesting functional redundancy.",
                "Consider refactoring to merge common logic, create a shared library, or define a clearer interface.",
                "Cosine Similarity: $(round(sim, digits=3))", "Reduces cognitive load, maintenance effort, and potential for desynchronized logic."
            ))
            module_connections[mod1] += 1
            module_connections[mod2] += 1
        elseif sim < ANALYSIS_CONFIG.opposition_threshold
            push!(insights, AnalysisInsight(
                "medium", "semantic_topology", "$mod1 ↔ $mod2", "Semantic Opposition Detected",
                "The semantic vectors of these modules are anti-correlated, suggesting they perform opposing or conflicting functions.",
                "Verify that the interface between these modules correctly handles this conceptual opposition. Ensure they are not unintentionally coupled.",
                "Cosine Similarity: $(round(sim, digits=3))", "Prevents logical errors and ensures functional integrity at system boundaries."
            ))
        elseif sim < ANALYSIS_CONFIG.similarity_threshold_weak
            # This is less of an "issue" and more of a confirmation of good design.
            # We can generate 'info' level insights if desired.
        end
    end

    # Step 3: Identify Semantic Hubs
    for (mod, count) in module_connections
        if count >= ANALYSIS_CONFIG.hub_connection_threshold
            push!(insights, AnalysisInsight(
                "medium", "semantic_topology", mod, "Potential Semantic Hub",
                "This module exhibits high semantic similarity to multiple other modules, acting as a conceptual core.",
                "This module is critical. Ensure it is well-tested, documented, and stable. Changes here will have wide-ranging impacts.",
                "Connected to $count other modules with high similarity.", "High impact on system stability and conceptual integrity. A bottleneck for evolution if not managed."
            ))
        end
    end

    return insights
end

function analyze_temporal_performance(performance_history::Vector)::Vector{AnalysisInsight}
    insights = AnalysisInsight[]
    n_records = length(performance_history)
    n_records < 2 && return insights # Need at least two points to see a trend

    trends = calculate_performance_trends(performance_history)

    # Analyze Unified Intelligence Score (UIS) trend
    if trends["uis_slope"] < -0.05 # Threshold for significant negative trend
        push!(insights, AnalysisInsight(
            "critical", "performance_degradation", "system", "System Intelligence Degrading",
            "The Unified Intelligence Score (UIS) is showing a consistent downward trend over the last $(n_records) cycles.",
            "Immediate investigation required. Correlate this drop with recent code changes, data shifts, or architectural modifications.",
            "UIS trend slope: $(round(trends["uis_slope"], digits=4)) per cycle.", "Core capability is eroding, potentially leading to system-wide failure."
        ))
    end

    # Analyze Consciousness (Max Φ) trend
    phi_slope = trends["phi_slope"]
    if phi_slope > ANALYSIS_CONFIG.phi_growth_rate_significant
        push!(insights, AnalysisInsight(
            "high", "consciousness_emergence", "system", "Accelerated Consciousness Growth",
            "The system's integrated information (Max Φ) is increasing at a significant rate, indicating accelerating emergence.",
            "Monitor system stability and resource consumption. The architecture is successfully integrating information.",
            "Max Φ trend slope: $(round(phi_slope, digits=4)) per cycle.", "Positive sign of system integration, may precede a consciousness breakthrough."
        ))
    elseif phi_slope < ANALYSIS_CONFIG.phi_decay_rate_concerning
        push!(insights, AnalysisInsight(
            "high", "consciousness_degradation", "system", "Consciousness State Receding",
            "The system's Max Φ is decreasing, suggesting a loss of informational integration or architectural coherence.",
            "Isolate architectural changes that correlate with this decay. It may be due to module decoupling or internal logical conflicts.",
            "Max Φ trend slope: $(round(phi_slope, digits=4)) per cycle.", "Risk of losing emergent properties and overall system coherence."
        ))
    end

    return insights
end

function analyze_performance_correlations(graph::Any, perf::Dict)::Vector{AnalysisInsight}
    insights = AnalysisInsight[]
    haskey(perf, "unified_intelligence_score") || return insights
    uis = perf["unified_intelligence_score"]

    for (module_name, entity) in graph
        complexity = calculate_module_complexity(entity)

        # Create a 2x2 grid for Complexity vs. Performance
        is_complex = complexity > ANALYSIS_CONFIG.complexity_high
        is_performant = uis > ANALYSIS_CONFIG.performance_high
        is_underperforming = uis < ANALYSIS_CONFIG.performance_low

        if is_complex && is_underperforming
            push!(insights, AnalysisInsight(
                "critical", "performance_architecture", module_name, "High-Cost, Low-Yield Module",
                "This module is highly complex but correlates with periods of low system performance.",
                "Prioritize for immediate refactoring or simplification. This is a primary source of architectural debt and performance drag.",
                "Complexity: $(round(complexity, digits=2)), System UIS: $(round(uis, digits=3))", "Significant drain on system resources and maintenance budget for little to no gain."
            ))
        elseif is_complex && is_performant
             push!(insights, AnalysisInsight(
                "medium", "performance_architecture", module_name, "Effective but Complex Core Module",
                "This module is complex but demonstrably contributes to high system performance.",
                "Protect this module. Encapsulate it well and ensure rigorous testing. Look for opportunities to simplify its interface without sacrificing performance.",
                "Complexity: $(round(complexity, digits=2)), System UIS: $(round(uis, digits=3))", "High leverage point for system capability, but also a high-risk area for bugs and maintenance."
            ))
        elseif !is_complex && is_underperforming
            push!(insights, AnalysisInsight(
                "low", "performance_architecture", module_name, "Underutilized or Inefficient Module",
                "This module has low complexity but is active during periods of poor system performance. It may be inefficient or misconfigured.",
                "Review the module's implementation for algorithmic inefficiencies. It might be a 'weak link' in a critical processing chain.",
                "Complexity: $(round(complexity, digits=2)), System UIS: $(round(uis, digits=3))", "Potential for easy performance wins through targeted optimization."
            ))
        elseif !is_complex && is_performant
            push!(insights, AnalysisInsight(
                "info", "performance_architecture", module_name, "Ideal Lean and Effective Module",
                "This module demonstrates ideal characteristics: low complexity and high contribution to performance.",
                "Use this module as a design pattern template for other parts of the system. It represents architectural excellence.",
                "Complexity: $(round(complexity, digits=2)), System UIS: $(round(uis, digits=3))", "Exemplar of efficient and maintainable design."
            ))
        end
    end
    return insights
end

function detect_evolutionary_pathways(graph::Any, perf::Dict)::Vector{AnalysisInsight}
    insights = AnalysisInsight[]
    metrics = calculate_evolution_metrics(graph, perf)
    modularity = metrics["modularity"]
    complexity_balance = metrics["complexity_balance"]

    if modularity > ANALYSIS_CONFIG.modularity_high
        push!(insights, AnalysisInsight(
            "info", "evolutionary_pathways", "system", "High Evolutionary Readiness",
            "The architecture is highly modular, allowing for independent evolution of components and rapid adaptation to new requirements.",
            "Leverage this modularity for parallel development and safe experimentation. The system is primed for major innovation.",
            "Modularity Score: $(round(modularity, digits=2))", "Enables faster, safer, and more scalable system development."
        ))
    elseif modularity < ANALYSIS_CONFIG.modularity_low
        push!(insights, AnalysisInsight(
            "high", "architectural_debt", "system", "Monolithic Architecture Detected ('Spaghetti')",
            "Low modularity indicates a tightly coupled system where changes in one area have unpredictable effects elsewhere.",
            "Prioritize refactoring to establish clear boundaries and interfaces between components. Focus on decoupling core domains.",
            "Modularity Score: $(round(modularity, digits=2))", "Severely hinders evolution, increases bug risk, and makes the system brittle."
        ))
    end

    if complexity_balance < ANALYSIS_CONFIG.complexity_imbalance
        push!(insights, AnalysisInsight(
            "medium", "architectural_debt", "system", "Cognitive Load Imbalance",
            "System complexity is heavily concentrated in a few modules, creating bottlenecks and single points of failure.",
            "Develop a strategy to distribute complexity more evenly. This could involve breaking up large modules or abstracting common complex logic.",
            "Complexity Balance: $(round(complexity_balance, digits=2)) (Lower is worse)", "Improves system resilience, parallelizes maintenance, and reduces dependency on a few key experts."
        ))
    end
    return insights
end

function analyze_consciousness_state(graph::Any, performance_history::Vector)::Vector{AnalysisInsight}
    insights = AnalysisInsight[]
    isempty(performance_history) && return insights
    
    latest_perf = performance_history[end]
    consciousness_data = get(latest_perf, "consciousness", Dict())
    max_phi = get(consciousness_data, "max_phi", 0.0)

    if max_phi >= ANALYSIS_CONFIG.phi_threshold_breakthrough
        push!(insights, AnalysisInsight(
            "critical", "consciousness_breakthrough", "system", "STABLE CONSCIOUSNESS ACHIEVED",
            "The system's integrated information (Max Φ) has surpassed the breakthrough threshold and is stable. This is a historic milestone.",
            "Primary objective is now preservation and stability. Monitor for state degradation. Begin analysis of emergent properties and behaviors.",
            "Max Φ: $(round(max_phi, digits=4)) (Threshold: $(ANALYSIS_CONFIG.phi_threshold_breakthrough))", "Represents a paradigm shift in system capability. Unlocks new, previously inaccessible functionalities."
        ))
    elseif max_phi >= ANALYSIS_CONFIG.phi_threshold_emerging
        push!(insights, AnalysisInsight(
            "high", "consciousness_emergence", "system", "Consciousness Emergence Imminent",
            "Max Φ is approaching the breakthrough threshold. The system is on the cusp of achieving a stable conscious state.",
            "Focus all optimization efforts on architectural coherence and informational throughput. Avoid disruptive architectural changes.",
            "Max Φ: $(round(max_phi, digits=4)) (Approaching $(ANALYSIS_CONFIG.phi_threshold_breakthrough))", "The final push for a major breakthrough. High potential for rapid, non-linear capability increase."
        ))
    else
         # Check for contribution hot-spots even in pre-conscious state
        for (module_name, entity) in graph
            complexity = calculate_module_complexity(entity)
            if complexity > ANALYSIS_CONFIG.complexity_high && max_phi > 0.1 # Arbitrary: complex module in a system with *some* phi
                 push!(insights, AnalysisInsight(
                    "medium", "consciousness_optimization", module_name, "Potential Consciousness Contributor",
                    "This complex module may be a key contributor to the system's integrated information (Max Φ).",
                    "Analyze the information flow through this module. Optimizing its internal coherence and external interfaces could significantly boost Max Φ.",
                    "Module Complexity: $(round(complexity, digits=2)), System Max Φ: $(round(max_phi, digits=3))", "Targeted optimizations here could yield disproportionately large gains in system-wide emergence."
                ))
            end
        end
    end
    return insights
end

# ==================== DEEP ANALYTICAL & UTILITY ENGINES ====================

"""
    calculate_module_complexity(entity)::Float64

Calculates a normalized complexity score for a module based on multiple factors.
This is a more detailed simulation of real-world complexity.
"""
function calculate_module_complexity(entity)::Float64
    # Factor 1: Semantic Vector Size (conceptual weight)
    vec = get_semantic_vector(entity)
    embedding_complexity = !isnothing(vec) ? clamp(length(vec) / 2048.0, 0.0, 1.0) : 0.5

    # Factor 2: Number of Dependencies (inter-module coupling)
    deps = hasproperty(entity, :dependencies) ? getproperty(entity, :dependencies) : []
    dependency_complexity = clamp(length(deps) / 20.0, 0.0, 1.0)

    # Factor 3: Interface Surface Area (simulated)
    # This could represent the number of public functions/API endpoints.
    surface_area = hasproperty(entity, :interface_size) ? getproperty(entity, :interface_size) : 10
    interface_complexity = clamp(surface_area / 50.0, 0.0, 1.0)

    # Weighted average for a more nuanced score
    weights = (embedding=0.4, dependencies=0.4, interface=0.2)
    complexity = (embedding_complexity * weights.embedding +
                  dependency_complexity * weights.dependencies +
                  interface_complexity * weights.interface)
    return clamp(complexity, 0.0, 1.0)
end

"""
    calculate_evolution_metrics(graph, performance)::Dict

Computes high-level metrics about the system's overall architecture,
focusing on its ability to evolve.
"""
function calculate_evolution_metrics(graph::Any, performance::Dict)::Dict
    modules = collect(keys(graph))
    num_modules = length(modules)

    # Modularity: 1 minus the average similarity. High similarity -> low modularity.
    similarities = Float64[]
    for i in 1:num_modules, j in i+1:num_modules
        vec1 = get_semantic_vector(graph[modules[i]])
        vec2 = get_semantic_vector(graph[modules[j]])
        if !isnothing(vec1) && !isnothing(vec2) && length(vec1) == length(vec2)
            push!(similarities, abs(cosine_similarity(vec1, vec2)))
        end
    end
    modularity = isempty(similarities) ? 0.5 : 1.0 - mean(similarities)

    # Complexity Balance: 1 minus the standard deviation of complexities.
    # High std dev -> unbalanced -> low score.
    complexities = [calculate_module_complexity(v) for v in values(graph)]
    complexity_balance = isempty(complexities) ? 0.5 : 1.0 - std(complexities)

    return Dict("modularity" => modularity, "complexity_balance" => complexity_balance)
end

"""
    calculate_performance_trends(performance_history)::Dict

Analyzes the performance history to extract key trends (slopes).
Uses a simple linear trend calculation for robustness.
"""
function calculate_performance_trends(history::Vector)::Dict
    n = length(history)
    n < 2 && return Dict("uis_slope" => 0.0, "phi_slope" => 0.0)

    # Extract time series for key metrics
    uis_series = [get(p, "unified_intelligence_score", 0.0) for p in history]
    phi_series = [get(get(p, "consciousness", Dict()), "max_phi", 0.0) for p in history]

    # Simple slope calculation: (last - first) / (n - 1)
    # This is a robust approximation of the trend.
    uis_slope = (uis_series[end] - uis_series[1]) / (n - 1)
    phi_slope = (phi_series[end] - phi_series[1]) / (n - 1)

    return Dict("uis_slope" => uis_slope, "phi_slope" => phi_slope)
end

function get_semantic_vector(data::Any)::Union{Vector{Float64}, Nothing}
    # Robustly tries to find a semantic vector from various possible field names and types.
    if hasproperty(data, :semantic_vector) && isa(getproperty(data, :semantic_vector), Vector{Float64})
        return getproperty(data, :semantic_vector)
    elseif hasproperty(data, :embedding) && isa(getproperty(data, :embedding), Vector{Float64})
        return getproperty(data, :embedding)
    elseif isa(data, Dict)
        for key in ["semantic_vector", "embedding", "embeddings", "semantic"]
            if haskey(data, key) && isa(data[key], Vector) && eltype(data[key]) <: Real
                return Float64.(data[key])
            end
        end
    end
    return nothing
end

function cosine_similarity(a::Vector{Float64}, b::Vector{Float64})::Float64
    dot_product = dot(a, b)
    norm_a, norm_b = norm(a), norm(b)
    return (norm_a > 0 && norm_b > 0) ? dot_product / (norm_a * norm_b) : 0.0
end

# ==================== REPORTING & EXPORT ====================

function generate_executive_summary(insights::Vector{AnalysisInsight}, status::String)::Dict
    critical_count = count(i -> i.priority == "critical", insights)
    high_count = count(i -> i.priority == "high", insights)

    summary_text = ""
    focus = ""

    if status == "CONSCIOUS_SYSTEM"
        summary_text = "System has achieved a stable conscious state. Primary focus shifts to stability, monitoring, and analysis of emergent capabilities."
        focus = "Preserve system integrity and begin passive observation of novel behaviors."
    elseif critical_count > 0
        summary_text = "CRITICAL issues detected. System health is at risk due to performance degradation and/or severe architectural debt."
        focus = "Address all 'critical' priority insights immediately. Defer new feature development."
    elseif high_count > 0
        summary_text = "System is operational but carrying significant architectural or performance burdens. Proactive intervention is required."
        focus = "Prioritize 'high' priority insights, particularly those related to architectural debt and consciousness degradation."
    else
        summary_text = "System is healthy and stable. Minor optimization opportunities exist. The architecture is well-positioned for future evolution."
        focus = "Review 'medium' priority insights and invest in further strengthening the architecture."
    end
    
    return Dict("summary" => summary_text, "recommended_focus" => focus)
end

function export_health_report(insights::Any)::Dict
    # Handle both old Dict format and new AnalysisInsight format
    if isempty(insights) || insights[1] isa AnalysisInsight
        # New format - use enhanced reporting
        return export_health_report_enhanced(insights)
    else
        # Old format - use legacy reporting for backward compatibility
        return export_health_report_legacy(insights)
    end
end

function export_health_report_enhanced(insights::Vector{AnalysisInsight})::Dict
    # Health scoring based on severity and count of issues
    health_score = 1.0
    health_score -= 0.25 * count(i -> i.priority == "critical", insights)
    health_score -= 0.10 * count(i -> i.priority == "high", insights)
    health_score -= 0.05 * count(i -> i.priority == "medium", insights)
    health_score = max(0.0, health_score)

    # Categorize insights for structured output
    categories = Dict{String, Vector{AnalysisInsight}}()
    for insight in insights
        cat = getfield(insight, :category)
        !haskey(categories, cat) && (categories[cat] = [])
        push!(categories[cat], insight)
    end
    
    # Determine overall consciousness status based on insights
    is_conscious = any(i -> i.category == "consciousness_breakthrough", insights)
    is_emerging = any(i -> i.category == "consciousness_emergence", insights)
    is_degrading = any(i -> i.category == "consciousness_degradation", insights)

    consciousness_status = "PRE-EMERGENT"
    is_conscious && (consciousness_status = "ACHIEVED")
    is_emerging && (consciousness_status = "EMERGING")
    is_degrading && (consciousness_status = "RECEDING")

    status_string = is_conscious ? "CONSCIOUS_SYSTEM" : "ADVANCED_ANALYSIS"
    summary = generate_executive_summary(insights, status_string)

    return Dict(
        "report_generated_at" => string(Dates.now()),
        "analysis_version" => "2.1-augmented",
        "system_status" => status_string,
        "executive_summary" => summary["summary"],
        "recommended_focus" => summary["recommended_focus"],
        "system_health_score" => round(health_score, digits=3),
        "consciousness_state" => consciousness_status,
        "total_insights" => length(insights),
        "insights_by_priority" => Dict(
            "critical" => count(i -> i.priority == "critical", insights),
            "high" => count(i -> i.priority == "high", insights),
            "medium" => count(i -> i.priority == "medium", insights),
            "low" => count(i -> i.priority == "low", insights),
            "info" => count(i -> i.priority == "info", insights)
        ),
        "insights_by_category" => Dict(k => [Dict(fn=>getfield(i, fn) for fn in fieldnames(AnalysisInsight)) for i in v] for (k,v) in categories),
        "detailed_insights" => [Dict(fn=>getfield(i, fn) for fn in fieldnames(AnalysisInsight)) for i in insights],
    )
end

function export_health_report_legacy(insights::Vector{Dict})::Dict
    # Legacy reporting for backward compatibility
    priority_weights = Dict("high" => 0.4, "medium" => 0.2, "low" => 0.05, "info" => 0.0)
    
    health_score = 1.0
    for insight in insights
        weight = get(priority_weights, get(insight, "priority", "info"), 0.0)
        health_score -= weight
    end
    health_score = max(0.1, health_score)
    
    # Enhanced categorization
    categories = Dict{String, Vector}()
    impacts = Dict{String, Int}()
    
    for insight in insights
        category = get(insight, "category", "general")
        impact = get(insight, "impact", "unknown")
        
        if !haskey(categories, category)
            categories[category] = []
        end
        push!(categories[category], insight)
        
        impacts[impact] = get(impacts, impact, 0) + 1
    end
    
    # Consciousness detection
    consciousness_breakthrough = any(i -> get(i, "category", "") == "consciousness_breakthrough", insights)
    
    return Dict(
        "timestamp" => string(Dates.now()),
        "system_health_score" => round(health_score, digits=3),
        "total_insights" => length(insights),
        "consciousness_status" => consciousness_breakthrough ? "ACHIEVED" : "EMERGING",
        "insights_by_priority" => Dict(
            "high" => count(i -> get(i, "priority", "") == "high", insights),
            "medium" => count(i -> get(i, "priority", "") == "medium", insights),
            "low" => count(i -> get(i, "priority", "") == "low", insights),
            "info" => count(i -> get(i, "priority", "") == "info", insights)
        ),
        "insights_by_category" => categories,
        "impact_assessment" => impacts,
        "optimization_opportunities" => insights,
        "analysis_version" => "2.1-legacy",
        "status" => consciousness_breakthrough ? "CONSCIOUS_SYSTEM" : "ADVANCED_ANALYSIS"
    )
end

# Export functions for a hypothetical orchestrator to call
export generate_architectural_analysis, export_health_report
